# -*- coding: utf-8 -*-
"""HW4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1_0MsMqUL2f8wGu5bSd7jdFLaPJJU__ZK

#Homework 4
###Part 1: Testing the avalanche properties of AES using an automated code
###Part 2: Encrypting and decrypting a file using AES and DES

##Part 1

Write 2 function to test the avalanche property of AES when different single bits of the inputblock are inverted.

In this experiment you receive an initial inputblock and key to perform AES encryption and find the cipherblock. Then you will use the bitlist provided as the 3rd input to the function to decide which bit of the inputblock to invert in additional experiments and then perform the AES encryption again on the modified input (with only one bit difference to original input)
Then you compare the ciphertext for each additional experiment with the ciphertext of the original experiment and count the number of bits that are different between them.

The output of your function will be the list of the number-of-differences from all experiments

Make sure you test your code before submission by setting the bitlist to [7] (i.e., the eighth bit) and comparing the results with Table 6.5 and Table 6.6 of the textbook. you can also try inverting other bit values manually and generate ciphers using the AES example we did in the class and compare with the output of your function.

As usual, we will import your submitted python file in another script and just call the aes_input_av_test() and aes_key_av_test() functions and check the output list of each function. It's ok if you have other utility functions in your submission and they will not be called or tested.
"""

# Make sure you install pycryptodome library before using any functions from the Crypto library.
!pip install pycryptodome

def aes_input_av_test(inputblock, key, bitlist):
    # inputblock and key are 16 byte long bytes values each
    # bitlist is a list of integers that define the position of the
    # bit in the inputblock that needs to be inverted, one at a time, for example
    # [0, 3, 6, 25, 78, 127]

    # 1- any initializations necessary
    diff_list = []

    # 2- perform encryption of the original values
    #    anyway you like. It doesn't have to be with
    #    with this exact function form
    originalcipher = aes_enc(inputblock, key)

    # 3- for every value given in the bitlist:
    for b in bitlist:
        #invert the value of the corresponding bit in the inputblock (doesn't have to be in this exact
        # function form)
        newinput = invertbit(inputblock, b)

        # perform encryption on the new input with one inverted bit at position b
        newcipher = aes_enc(newinput, key)

        # find the number of bit differences between the two ciphertexts (doesn't have to be exactly in
        # this function form)
        # Use any method you like to find the difference.
        numbitdifferences = findbitdiff(originalcipher, newcipher)

        # add it to the list
        diff_list.append(numbitdifferences)

    # return the list of numbers
    return diff_list


# We also perform similar experiment by keeping the inputblock fixed and changing the
# selected bits of the key
def aes_key_av_test(inputblock, key, bitlist):
    # inputblock and key are 16 byte values each
    # bitlist is a list of integers that define the position of the
    # bit in the key that needs to be inverted, one at a time, for example
    # [0, 3, 6, 25, 78, 127]

    # 1- any initializations necessary
    diff_list = []

    # 2- perform encryption of the original values
    #    anyway you like. It doesn't have to be with
    #    with this exact function form
    originalcipher = aes_enc(inputblock, key)

    # 3- for every value given in the bitlist:
    for b in bitlist:
        #invert the value of the corresponding bit in the key (doesn't have to be in this exact
        # function form)
        newkey = invertbit(key, b)

        # perform encryption with the new key with one inverted bit at position b
        newcipher = aes_enc(inputblock, newkey)

        # find the number of bit differences between the two ciphertexts (doesn't have to be exactly in
        # this function form)
        numbitdifferences = findbitdiff(originalcipher, newcipher)

        # add it to the list
        diff_list.append(numbitdifferences)

    # return the list of numbers
    return diff_list

"""##Part 2

Write two functions to perform DES & AES encryption and decryption on a file.
Function 1 encrypt_file() will accept 5 parameters in the following exact order. Input file name, DES key, AES key, DES ciphertext output filename, AES ciphertext output filename.

The second function decrypt_files() will accept 6 parameters in the following exact order. DES ciphertext file name, AES ciphertext file name, DES key, AES key, DES plaintext output filename, AES plaintext output filename.

All filesnames should be only filenames in the current directory as your program. The file names will be passed as strings.

Make sure you close all file handlers!

All keys will be of the type bytes, where AES key will be 16 bytes long and DES key will be 8 bytes long.

As usual, we will import your submitted python file in another script and just call the encrypt_file() and decrypt_files() functions and check the output files from each function. It's ok if you have other utility functions in your submission and they will not be called or tested.

Both functions should return 0 on successful execution. The grading script will not check the output files unless 0 is returned by the function.
"""

def encrypt_file(inputfile,des_key,aes_key,des_output_file,aes_output_file):

    #This function should create 2 output files. One with DES encryption, and the other with AES encryption.

    #Open a read file handler for the input file.
    finp = open(inputfile,'rb')
    #rb stands for read bytes.
    #Then read the bytes from the file and store them in a variable.
    filebytes = finp.read()
    #Then close the file.
    finp.close()


    '''
    For DES:
    in a loop, break filebytes into 8 bytes chunks and pad the last set of bytes if the length is not 8
    run encryption for each block of 8 bytes
    Then write the final ciphertext in the output file
    '''

    fout_des = open(des_output_file,'wb')
    #wb stands for write bytes
    fout_des.write(des_ciphertext)
    fout_des.close()


    '''
    For AES:
    in a loop, break filebytes into 16 bytes chunks and pad the last set of bytes if the length is not 16
    run encryption for each block of 16 bytes
    Then write the final ciphertext in the output file
    '''
    fout_aes = open(aes_output_file,'wb')
    #wb stands for write bytes
    fout_aes.write(aes_ciphertext)
    fout_aes.close()

    return 0


def decrypt_file(des_input_file,aes_input_file,des_key,aes_key,des_output_file,aes_output_file):

    #This function should create 2 output files. One for DES decryption, and the other for AES decryption.

    #Open a read file handler for the DES ciphertext input file.
    finp_des = open(des_input_file,'rb')
    #rb stands for read bytes.
    #Then read the bytes from the file and store them in a variable.
    filebytes_des = finp_des.read()
    #Then close the file.
    finp_des.close()


    '''
    For DES:
    in a loop, break filebytes into 8 bytes chunks
    run decryption for each block of 8 bytes
    Then write the final plaintext in the output file
    '''

    fout_des = open(des_output_file,'wb')
    #wb stands for write bytes
    fout_des.write(des_plaintext)
    fout_des.close()


    #Open a read file handler for the AES ciphertext input file.
    finp_aes = open(aes_input_file,'rb')
    #rb stands for read bytes.
    #Then read the bytes from the file and store them in a variable.
    filebytes_aes = finp_aes.read()
    #Then close the file.
    finp_aes.close()

    '''
    For AES:
    in a loop, break filebytes into 16 bytes chunks
    run decryption for each block of 16 bytes
    Then write the final plaintext in the output file
    '''
    fout_aes = open(aes_output_file,'wb')
    #wb stands for write bytes
    fout_aes.write(aes_plaintext)
    fout_aes.close()

    return 0