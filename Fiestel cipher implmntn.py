# -*- coding: utf-8 -*-
"""Untitled2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1r-knv5z4a-Vd8JHFnv6Rck3OE1AzK51Z
"""

UID_no = 118406473                                     
Last_Name = "Kanna"
First_Name = "Suprajha"

import hmac
import hashlib
import random

def xor(byteseq1, byteseq2):
  l1 = [b for b in byteseq1]             #the xor operation is performed on blocks 
  l2 = [b for b in byteseq2] 
  l1attachl2 = zip(l1,l2)
  l1xorl2 = [bytes([elem1^elem2]) for elem1,elem2 in l1attachl2]
  result = b''.join(l1xorl2)
  return result

def feistel_block(LE_inp, RE_inp, k):

  LE_out = RE_inp                      #LE16 = RE15
  byte_val = b''.join(k)
                                       #traverse in the string  
  RE_xor = F(RE_inp,byte_val,8)        #the right block value is calculated sending the input byte sequence, key and output length to the function in order to calculate the hash value
  RE_out = xor(LE_inp,RE_xor)          #Post function calculation, the value is sent to XOR function which generates the next right block
  return LE_out, RE_out                #the left block is sent as it is and right value is sent after the xor calculation

  # The round function F to the right half of the data and then taking the exclusive-OR of the output of that function and the left half of the data

def F(byteseq, k, outputlen):
  # we use the hmac hash (don't worry about the meaning for now)
  h = hmac.new(k, byteseq, hashlib.sha1)
  # return the first outputlen bytes of the hash value
  return h.digest()[:outputlen]

def gen_keylist(keylenbytes, numkeys, seed):
    # We need to generate numkeys keys each being keylen bytes long
    random.seed(seed)
    #from the seed key, the next list of keys are generated
    # keylist = [numkeys elements of 'bytes' type and keylenbytes bytes long each]
    keylist = []
    for i in range(numkeys):
      bytelist = [bytes([random.randint(0,255)]) for x in range(keylenbytes)]
      keylist.append(bytelist)
    # example [b'\x12\xa4\x2f\xb4\x67\x80\xd4\x12', and 15 more if numkeys is 16]
    return keylist
                                                #ENCRYPTION FUNCTION
def feistel_enc(ip, rounds_in_enc, mk):
    # this function takes 3 inputs namely the input, number of rounds required in the encryption and key to encrypt the input received
    # the number of keys required is generated and stored in the keylist
    keylist = gen_keylist(8, rounds_in_enc, mk) 
    LE_half = ip[0:8]                         #the first set of block is stored in the left block half
    RE_half = ip[8:16]                        #the next set of block is stored in the right block half

   #left block value is calculated and stored in LE_half
    if(len(LE_half)<8):
       len_val = 8-len(LE_half)
       for x in range(len_val):
         LE_half = LE_half + b'\x20'
         
   #right block value is calculated and stored in RE_half
    if(len(RE_half)<8):
      right_val = 8-len(RE_half)
      for x in range(right_val):
        RE_half = RE_half + b'\x20'
    #both block values are sent to the Fiestel block function     
    for i in range(0,16):
        LE_half, RE_half = feistel_block(LE_half, RE_half, keylist[i])
    #the entire cipher text is calculated by adding both the blocks together
    cipher_val = RE_half + LE_half
    return cipher_val
                                                   #DECRYPTION FUNCTION
def feistel_dec(ip, rounds_in_dec, mk):
  # this function takes 3 inputs namely the input, number of rounds required in the decryption and key to decrypt the input received
  # the number of keys required is generated and stored in the keylist
  keylist = gen_keylist(8, rounds_in_dec, mk)  
  LE_half = ip[0:8]                       #the first set of block is stored in the left block half
  RE_half = ip[8:16]                      #the next set of block is stored in the right block half
  for i in range(0,16):
      LE_half, RE_half = feistel_block(LE_half, RE_half, keylist[15-i])         #the subkeys Ki in reverse order i.e., kn use in the first round, kn-1 in the second round and sent to Fiestel block calculation
  plaintext_val = RE_half + LE_half                                             #the plaintext is calculated adding the two blocks
  return plaintext_val

if __name__ == "__main__":                                          
    encryptdstr_val = feistel_enc(b'isthis16bytes',16,50)        #encryption value is sent to the encryption function
    print("The encrypted block is...",encryptdstr_val)            
    decryptdstr_val = feistel_dec(b'}\xd9\x93-G\x8e\xaa5\x95\x84\n\xb7q\xc4>\xb6',16,50)     #decryption value is sent to the decryption function
    print("The decryptd value is:",decryptdstr_val)