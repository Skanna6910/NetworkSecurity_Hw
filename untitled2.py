# -*- coding: utf-8 -*-
"""Untitled2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1r-knv5z4a-Vd8JHFnv6Rck3OE1AzK51Z
"""

UID_no = 118406473
Last_Name = "Kanna"
First_Name = "Suprajha"

import hmac
import hashlib
import random

def xor(byteseq1, byteseq2):
  l1 = [b for b in byteseq1]             #the xor operation is performed on blocks
  l2 = [b for b in byteseq2]
  l1attachl2 = zip(l1,l2)
  l1xorl2 = [bytes([elem1^elem2]) for elem1,elem2 in l1attachl2]
  result = b''.join(l1xorl2)
  return result

def feistel_block(LE_inp, RE_inp, k):

  LE_out = RE_inp                      #LE16 = RE15
  byte_val = b''.join(k)
                                       #traverse in the string
  RE_xor = F(RE_inp,byte_val,8)        #the right block value is calculated sending the input byte sequence, key and output length to the function in order to calculate the hash value
  RE_out = xor(LE_inp,RE_xor)          #Post function calculation, the value is sent to XOR function which generates the next right block
  return LE_out, RE_out                #the left block is sent as it is and right value is sent after the xor calculation

  # The round function F to the right half of the data and then taking the exclusive-OR of the output of that function and the left half of the data

def F(byteseq, k, outputlen):
  # we use the hmac hash (don't worry about the meaning for now)
  h = hmac.new(k, byteseq, hashlib.sha1)
  # return the first outputlen bytes of the hash value
  return h.digest()[:outputlen]

def gen_keylist(keylenbytes, numkeys, seed):
    # We need to generate numkeys keys each being keylen bytes long
    random.seed(seed)
    #from the seed key, the next list of keys are generated
    # keylist = [numkeys elements of 'bytes' type and keylenbytes bytes long each]
    keylist = []
    for i in range(numkeys):
      bytelist = [bytes([random.randint(0,255)]) for x in range(keylenbytes)]
      keylist.append(bytelist)
    # example [b'\x12\xa4\x2f\xb4\x67\x80\xd4\x12', and 15 more if numkeys is 16]
    return keylist
                                                #ENCRYPTION FUNCTION
def feistel_enc(ip, rounds_in_enc, mk):
    # this function takes 3 inputs namely the input, number of rounds required in the encryption and key to encrypt the input received
    # the number of keys required is generated and stored in the keylist
    keylist = gen_keylist(8, rounds_in_enc, mk)
    LE_half = ip[0:8]                         #the first set of block is stored in the left block half
    RE_half = ip[8:16]                        #the next set of block is stored in the right block half

   #left block value is calculated and stored in LE_half
    if(len(LE_half)<8):
       len_val = 8-len(LE_half)
       for x in range(len_val):
         LE_half = LE_half + b'\x20'

   #right block value is calculated and stored in RE_half
    if(len(RE_half)<8):
      right_val = 8-len(RE_half)
      for x in range(right_val):
        RE_half = RE_half + b'\x20'
    #both block values are sent to the Fiestel block function
    for i in range(0,16):
        LE_half, RE_half = feistel_block(LE_half, RE_half, keylist[i])
    #the entire cipher text is calculated by adding both the blocks together
    cipher_val = RE_half + LE_half
    return cipher_val
                                                   #DECRYPTION FUNCTION
def feistel_dec(ip, rounds_in_dec, mk):
  # this function takes 3 inputs namely the input, number of rounds required in the decryption and key to decrypt the input received
  # the number of keys required is generated and stored in the keylist
  keylist = gen_keylist(8, rounds_in_dec, mk)
  LE_half = ip[0:8]                       #the first set of block is stored in the left block half
  RE_half = ip[8:16]                      #the next set of block is stored in the right block half
  for i in range(0,16):
      LE_half, RE_half = feistel_block(LE_half, RE_half, keylist[15-i])         #the subkeys Ki in reverse order i.e., kn use in the first round, kn-1 in the second round and sent to Fiestel block calculation
  plaintext_val = RE_half + LE_half                                             #the plaintext is calculated adding the two blocks
  return plaintext_val

if __name__ == "__main__":
    encryptdstr_val = feistel_enc(b'isthis16bytes',16,50)        #encryption value is sent to the encryption function
    print("The encrypted block is...",encryptdstr_val)
    decryptdstr_val = feistel_dec(b'}\xd9\x93-G\x8e\xaa5\x95\x84\n\xb7q\xc4>\xb6',16,50)     #decryption value is sent to the decryption function
    print("The decryptd value is:",decryptdstr_val)

#ENCRYPTION
from numpy import matrixlib
import math
import numpy
UID = "118406473"
FirstName = "Suprajha"
LastName = "Kanna"
def row_trans_enc(msg,key):
  key_len = len(key)
  key_list = list(key)
  msg_list = list(msg)
  msg_len = int(len(msg))
  k_ptr = 0
  col = len(key)
  row = int(math.ceil(msg_len/col))
  print("ENCRYPTION")
  #print('\n')
  print("The message displayed as list: ",msg_list)
  print("The message length: ",msg_len)
  print("The key list is displayed as: ",key_list)
  print("The key length is: ",col)
  CT = ""

  print("The row & col value is...",row,col)
  pad_val = int((row*col)-msg_len)
  print("The padding value is found to be: ",pad_val)
  #msg_padded = msg_list.extend('_' * pad_val)
  msg_padded = msg + pad_val * 'X'
  msg_padded_list = list(msg_padded)
  print("Message with padding dispalyed as list: ",msg_padded_list)
  #print('\n')
  orderlist = numpy.argsort(key_list)
  matrix = []
  matrix = [msg_padded_list[i: i + col]
              for i in range(0, len(msg_padded_list), col)]
  print("The matrix is written as:", matrix)
  for x in orderlist:
    for y in range(0,len(matrix)):
      CT += matrix[y][x]
  return CT

msg = "ATTACKPOSTPONEDUNTILTWOAM"
key = "4312567"
encrypted_val = row_trans_enc(msg,key)
print("The encrypted cipher text value is... ",encrypted_val)
                                                        #DECRYPTION
def row_trans_dec(msg1,key1):
  print('\n')
  print('\n')
  key1_len = len(key1)
  key1_list = list(key)
  #key_int = int(key)
  #print("int key is..",key_int)
  msg1_list = list(msg1)
  msg1_len = int(len(msg1))
  k_ptr = 0
  msg_ptr = 0

  col1 = int(math.ceil(msg1_len/key1_len))
  row1 = len(key1)
  PT = ""
  print("DECRYPTION")
  print("The ciphertext displayed as list: ",msg1_list)
  print("The ciphertext length: ",msg1_len)
  print("The key list is displayed as: ",key1_list)
  print("The key length is: ",col1)
  a = list(map(int, key1_list))
  print("The row & col value is...",row1,col1)
  Pad_x_regions = (row1*col1) - len(msg)
  print("The extra padding inside matrix..",Pad_x_regions)
  orderlist1 = numpy.argsort(key1_list)
  print("The key order list is..",orderlist1)
  dec_matrix = []
  dec_matrix = [msg1_list[i: i + col1]
              for i in range(0, len(msg1_list), col1)]
  print("The dec_matrix is written as:", dec_matrix)

  for d in range(col1):
      for j in range(row1):
       PT = PT + dec_matrix[a[j]-1][d]
  return PT
  #col_new = 0
  #row_new = 0
  #for s in msg1:
    #PT[col_new] += s
   # col_new += 1
    #if((col_new == col1) or (col_new == col1-1) and (row_new == row1 - Pad_x_regions)):
    #  col_new = 0
     # row_new += row_new

msg1 = "TTNAAPTMTSUOAODWCOIXKNLXPETX"
key1 = "4312567"
decrypted_val = row_trans_dec(msg1,key1)
print("The decrypted cipher text value is... ",decrypted_val)